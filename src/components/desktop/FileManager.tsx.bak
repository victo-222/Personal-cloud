import { useState, useEffect, useCallback, useRef } from "react";
import { supabase } from "@/integrations/supabase/client";
import { Button } from "@/components/ui/button";
import { 
  Folder, FileText, Plus, Trash2, Edit2, Download, Upload, Copy, Move, Search as SearchIcon, Image as ImageIcon, Code, Music, GripVertical,
  ChevronLeft, ChevronRight, Home, Heart, Clock, HardDrive, Zap, Settings, Eye, EyeOff, Archive, Share2, MoreVertical, List, LayoutGrid,
  Grid3x3, FileImage, Calendar, Size, FileUp, Link as LinkIcon, X, LogOut
} from "lucide-react";
import { useToast } from "@/hooks/use-toast";

interface UserFile {
  id: string;
  name: string;
  content: string | null;
  file_type: string;
  parent_folder: string;
  created_at?: string;
  size?: number;
}

interface Tab {
  id: string;
  path: string[];
  label: string;
}

type ViewMode = "grid" | "list" | "details" | "tiles" | "thumbnails";
type SortOption = "name" | "size" | "type" | "date";
type GroupOption = "none" | "type" | "date";

export const FileManager = () => {
  // Core state
  const [files, setFiles] = useState<UserFile[]>([]);
  const [folderStack, setFolderStack] = useState<string[]>(["root"]);
  const currentFolder = folderStack[folderStack.length - 1] ?? "root";
  const [selectedFile, setSelectedFile] = useState<UserFile | null>(null);
  
  // UI state
  const [contextMenu, setContextMenu] = useState<{ x: number; y: number; id: string } | null>(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [sortBy, setSortBy] = useState<SortOption>("name");
  const [groupBy, setGroupBy] = useState<GroupOption>("none");
  const [viewMode, setViewMode] = useState<ViewMode>("grid");
  const [multiSelect, setMultiSelect] = useState<string[]>([]);
  const [draggedItem, setDraggedItem] = useState<string | null>(null);
  const [dragOverFolder, setDragOverFolder] = useState<string | null>(null);
  const [showHidden, setShowHidden] = useState(false);
  const [showExtensions, setShowExtensions] = useState(true);
  const [favorites, setFavorites] = useState<string[]>([]);
  const [clipboard, setClipboard] = useState<{ items: string[], operation: "copy" | "cut" } | null>(null);
  const [trash, setTrash] = useState<UserFile[]>([]);
  const [showTrash, setShowTrash] = useState(false);
  
  // Tabs and navigation
  const [tabs, setTabs] = useState<Tab[]>([{ id: "1", path: ["root"], label: "Home" }]);
  const [activeTab, setActiveTab] = useState("1");
  const [pathInput, setPathInput] = useState("");
  const [showAddressBar, setShowAddressBar] = useState(false);
  
  // Advanced search state
  const [advancedSearch, setAdvancedSearch] = useState(false);
  const [searchFilters, setSearchFilters] = useState({
    type: "",
    minSize: 0,
    maxSize: 0,
    dateAfter: "",
    dateBefore: "",
  });
  
  // Creation and UI
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const [isCreating, setIsCreating] = useState(false);
  const [newName, setNewName] = useState("");
  const [createType, setCreateType] = useState<"file" | "folder">("file");
  const [showQuickActions, setShowQuickActions] = useState(false);
  const { toast } = useToast();


  const fetchFiles = useCallback(async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return;

    const currentPath = showTrash ? "trash" : currentFolder;
    const { data } = await supabase
      .from("user_files")
      .select("*")
      .eq("user_id", user.id)
      .eq("parent_folder", currentPath)
      .order("file_type", { ascending: false })
      .order("name");

    if (data) setFiles(data);
  }, [currentFolder, showTrash]);

  useEffect(() => {
    fetchFiles();
  }, [fetchFiles]);

  // Navigation helpers
  const getActiveFolderStack = () => {
    const tab = tabs.find(t => t.id === activeTab);
    return tab?.path || ["root"];
  };

  const setActiveFolderStack = (path: string[]) => {
    setTabs(prev => prev.map(t => t.id === activeTab ? { ...t, path } : t));
    setSelectedFile(null);
  };

  const goBack = () => {
    const currentPath = getActiveFolderStack();
    if (currentPath.length > 1) {
      setActiveFolderStack(currentPath.slice(0, -1));
    }
  };

  const goForward = () => {
    // Note: This is a simplified version - would need history stack for full implementation
    // Left as placeholder for enhancement
    toast({ title: "Info", description: "Forward navigation available with history" });
  };

  const navigateUp = () => {
    const currentPath = getActiveFolderStack();
    setActiveFolderStack(currentPath.length > 1 ? currentPath.slice(0, -1) : ["root"]);
    setSelectedFile(null);
  };

  const navigateToPath = (path: string) => {
    const folders = path.split("/").filter(f => f.length > 0);
    setActiveFolderStack(folders.length > 0 ? folders : ["root"]);
    setShowAddressBar(false);
  };

  const openNewTab = () => {
    const newId = Date.now().toString();
    setTabs([...tabs, { id: newId, path: ["root"], label: "Home" }]);
    setActiveTab(newId);
  };

  const closeTab = (id: string) => {
    if (tabs.length === 1) {
      toast({ title: "Info", description: "At least one tab must remain open" });
      return;
    }
    const newTabs = tabs.filter(t => t.id !== id);
    setTabs(newTabs);
    if (activeTab === id) {
      setActiveTab(newTabs[0].id);
    }
  };

  // File operations
  const createItem = async () => {
    if (!newName.trim()) return;

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return;

    const { error } = await supabase.from("user_files").insert({
      user_id: user.id,
      name: newName,
      content: createType === "file" ? "" : null,
      file_type: createType === "folder" ? "folder" : "text",
      parent_folder: currentFolder,
    });

    if (error) {
      toast({ title: "Error", description: error.message, variant: "destructive" });
      return;
    }

    setNewName("");
    setIsCreating(false);
    fetchFiles();
    toast({ title: "Created", description: `${createType === "folder" ? "Folder" : "File"} created` });
  };

  const deleteItem = async (id: string, toTrash = true) => {
    if (toTrash) {
      const item = files.find(f => f.id === id);
      if (item) {
        const { error } = await supabase.from("user_files").update({ parent_folder: "trash" }).eq("id", id);
        if (error) {
          toast({ title: "Error", description: error.message, variant: "destructive" });
          return;
        }
        setTrash([...trash, item]);
        toast({ title: "Deleted", description: "Item moved to trash" });
      }
    } else {
      const { error } = await supabase.from("user_files").delete().eq("id", id);
      if (error) {
        toast({ title: "Error", description: error.message, variant: "destructive" });
        return;
      }
      toast({ title: "Permanently deleted", description: "Item cannot be recovered" });
    }
    setSelectedFile(null);
    fetchFiles();
  };

  const emptyTrash = async () => {
    for (const item of trash) {
      await supabase.from("user_files").delete().eq("id", item.id);
    }
    setTrash([]);
    fetchFiles();
    toast({ title: "Trash emptied" });
  };

  const restoreFromTrash = async (id: string) => {
    const item = trash.find(f => f.id === id);
    if (!item) return;
    const { error } = await supabase.from("user_files").update({ parent_folder: "root" }).eq("id", id);
    if (error) {
      toast({ title: "Error", description: error.message, variant: "destructive" });
      return;
    }
    setTrash(trash.filter(f => f.id !== id));
    fetchFiles();
    toast({ title: "Restored", description: "Item restored to home folder" });
  };

  const openItem = (file: UserFile) => {
    if (file.file_type === "folder") {
      setActiveFolderStack([...getActiveFolderStack(), file.name]);
      setSelectedFile(null);
    } else {
      setSelectedFile(file);
    }
  };

  const renameItem = async (id: string) => {
    const item = files.find((f) => f.id === id);
    if (!item) return;
    const newNamePrompt = window.prompt("Rename item", item.name);
    if (!newNamePrompt || newNamePrompt.trim() === item.name) return;
    const { error } = await supabase.from("user_files").update({ name: newNamePrompt }).eq("id", id);
    if (error) return toast({ title: "Error", description: error.message, variant: "destructive" });
    fetchFiles();
    toast({ title: "Renamed", description: "Item renamed" });
  };

  const downloadItem = (file: UserFile) => {
    if (!file.content) return toast({ title: "Empty", description: "No content to download" });
    try {
      const blob = new Blob([file.content], { type: "application/octet-stream" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = file.name;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      toast({ title: "Downloaded", description: `${file.name} downloaded` });
    } catch (e) {
      toast({ title: "Error", description: "Failed to download" , variant: "destructive"});
    }
  };

  // Clipboard operations
  const copyFiles = (ids: string[]) => {
    setClipboard({ items: ids, operation: "copy" });
    toast({ title: "Copied", description: `${ids.length} item(s) copied` });
  };

  const cutFiles = (ids: string[]) => {
    setClipboard({ items: ids, operation: "cut" });
    toast({ title: "Cut", description: `${ids.length} item(s) cut` });
  };

  const pasteFiles = async () => {
    if (!clipboard) return;
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return;

    for (const id of clipboard.items) {
      if (clipboard.operation === "cut") {
        await supabase.from("user_files").update({ parent_folder: currentFolder }).eq("id", id);
      } else {
        const file = files.find(f => f.id === id);
        if (file) {
          await supabase.from("user_files").insert({
            user_id: user.id,
            name: `${file.name} (Copy)`,
            content: file.content,
            file_type: file.file_type,
            parent_folder: currentFolder,
          });
        }
      }
    }

    setClipboard(null);
    fetchFiles();
    toast({ title: "Pasted", description: "Items pasted successfully" });
  };

  const moveItemToFolder = async (itemId: string, targetFolderName: string) => {
    const { error } = await supabase.from("user_files").update({ parent_folder: targetFolderName }).eq("id", itemId);
    if (error) return toast({ title: "Error", description: error.message, variant: "destructive" });
    fetchFiles();
    toast({ title: "Moved", description: `Item moved to ${targetFolderName}` });
  };

  const toggleFavorite = (folderName: string) => {
    setFavorites(prev => prev.includes(folderName) ? prev.filter(f => f !== folderName) : [...prev, folderName]);
  };

  // Search and filter helpers
  const filterFiles = (fileList: UserFile[]) => {
    let result = fileList.slice();

    // Text search
    if (searchTerm.trim()) {
      result = result.filter((f) => f.name.toLowerCase().includes(searchTerm.toLowerCase()));
    }

    // Advanced filters
    if (advancedSearch) {
      if (searchFilters.type) {
        result = result.filter((f) => f.file_type.includes(searchFilters.type));
      }
      if (searchFilters.minSize > 0 && searchFilters.maxSize > 0) {
        result = result.filter((f) => {
          const size = f.content?.length || 0;
          return size >= searchFilters.minSize && size <= searchFilters.maxSize;
        });
      }
    }

    return result;
  };

  const sortFiles = (fileList: UserFile[]) => {
    const result = fileList.slice();
    
    switch (sortBy) {
      case "name":
        result.sort((a, b) => a.name.localeCompare(b.name));
        break;
      case "size":
        result.sort((a, b) => (b.content?.length || 0) - (a.content?.length || 0));
        break;
      case "type":
        result.sort((a, b) => a.file_type.localeCompare(b.file_type));
        break;
      case "date":
        result.sort((a, b) => new Date(b.created_at || 0).getTime() - new Date(a.created_at || 0).getTime());
        break;
    }
    
    return result;
  };

  const groupFiles = (fileList: UserFile[]) => {
    if (groupBy === "none") return { "": fileList };

    const grouped: Record<string, UserFile[]> = {};

    for (const file of fileList) {
      let key = "";
      if (groupBy === "type") {
        key = file.file_type;
      } else if (groupBy === "date") {
        const date = new Date(file.created_at || Date.now());
        key = date.toLocaleDateString();
      }

      if (!grouped[key]) grouped[key] = [];
      grouped[key].push(file);
    }

    return grouped;
  };

  const handleUploadFiles = async (filesList: FileList | null) => {
    if (!filesList) return;
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return toast({ title: "Not signed in" });
    
    for (let i = 0; i < filesList.length; i++) {
      const f = filesList[i];
      const text = await f.text();
      const fileType = f.type || "binary";
      const { error } = await supabase.from("user_files").insert({
        user_id: user.id,
        name: f.name,
        content: text,
        file_type: fileType.startsWith("image") ? "image" : "text",
        parent_folder: currentFolder,
      });
      if (error) toast({ title: "Upload error", description: error.message, variant: "destructive" });
    }
    fetchFiles();
    toast({ title: "Uploaded", description: `${filesList.length} file(s) uploaded` });
  };

  const toggleSelect = (id: string) => {
    setMultiSelect((s) => (s.includes(id) ? s.filter((x) => x !== id) : [...s, id]));
  };

  const selectAll = () => {
    setMultiSelect(files.map(f => f.id));
  };

  const deselectAll = () => {
    setMultiSelect([]);
  };

  // ZIP functionality (simplified - for real app would use JSZip)
  const zipFiles = async () => {
    toast({ title: "Info", description: "ZIP functionality requires JSZip library integration" });
  };

  const getFileIcon = (fileType: string, fileName: string) => {
    if (fileType === "folder") return <Folder className="w-6 h-6 text-blue-500" />;
    if (fileType === "image") return <ImageIcon className="w-6 h-6 text-purple-500" />;
    if (fileType.includes("audio") || fileName.endsWith(".mp3")) return <Music className="w-6 h-6 text-pink-500" />;
    if (fileType.includes("text") || fileType === "text") return <Code className="w-6 h-6 text-green-500" />;
    if (fileName.endsWith(".zip") || fileName.endsWith(".rar") || fileName.endsWith(".7z")) return <Archive className="w-6 h-6 text-yellow-600" />;
    return <FileText className="w-6 h-6 text-slate-500" />;
  };

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.ctrlKey || e.metaKey) {
        if (e.key === "c" && selectedFile) {
          e.preventDefault();
          copyFiles([selectedFile.id]);
        } else if (e.key === "x" && selectedFile) {
          e.preventDefault();
          cutFiles([selectedFile.id]);
        } else if (e.key === "v") {
          e.preventDefault();
          pasteFiles();
        } else if (e.key === "a") {
          e.preventDefault();
          selectAll();
        } else if (e.key === "n") {
          e.preventDefault();
          setIsCreating(true);
          setCreateType("file");
        }
      } else if (e.key === "Delete" && selectedFile) {
        e.preventDefault();
        deleteItem(selectedFile.id);
      } else if (e.key === "F5") {
        e.preventDefault();
        fetchFiles();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [selectedFile, currentFolder, clipboard]);

  return (
    <div className="h-full flex flex-col bg-background">
      {/* Tabs Bar */}
      <div className="flex items-center bg-card border-b border-border px-2 py-1 overflow-x-auto">
        {tabs.map((tab, idx) => (
          <div
            key={tab.id}
            className={`flex items-center gap-1 px-3 py-1.5 rounded-t border-b-2 cursor-pointer transition-colors ${
              activeTab === tab.id
                ? "bg-primary/10 border-primary text-foreground"
                : "border-transparent text-muted-foreground hover:bg-card/50"
            }`}
            onClick={() => setActiveTab(tab.id)}
          >
            <Home className="w-4 h-4" />
            <span className="text-sm max-w-xs truncate">{tab.label}</span>
            {tabs.length > 1 && (
              <X
                className="w-3 h-3 hover:text-destructive"
                onClick={(e) => { e.stopPropagation(); closeTab(tab.id); }}
              />
            )}
          </div>
        ))}
        <Button
          size="sm"
          variant="ghost"
          className="ml-auto"
          onClick={openNewTab}
          title="Open new tab (Ctrl+T)"
        >
          <Plus className="w-4 h-4" />
        </Button>
      </div>

      {/* Navigation & Address Bar */}
      <div className="flex items-center gap-2 p-2 bg-card border-b border-border flex-wrap">
        <div className="flex items-center gap-1">
          <Button size="sm" variant="ghost" onClick={goBack} title="Back (Alt+Left)">
            <ChevronLeft className="w-4 h-4" />
          </Button>
          <Button size="sm" variant="ghost" onClick={goForward} title="Forward (Alt+Right)" disabled>
            <ChevronRight className="w-4 h-4" />
          </Button>
          <Button size="sm" variant="ghost" onClick={navigateUp} title="Up (Alt+Up)">
            <ChevronLeft className="w-4 h-4 rotate-90" />
          </Button>
        </div>

        {/* Address Bar */}
        <div className="flex items-center gap-1 flex-1 max-w-md">
          {showAddressBar ? (
            <input
              type="text"
              value={pathInput}
              onChange={(e) => setPathInput(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && navigateToPath(pathInput)}
              placeholder="Enter path..."
              className="flex-1 px-2 py-1 text-sm bg-background border border-border rounded focus:border-primary outline-none"
              autoFocus
            />
          ) : (
            <button
              onClick={() => { setShowAddressBar(true); setPathInput(getActiveFolderStack().join("/")); }}
              className="flex-1 px-2 py-1 text-sm bg-background border border-border rounded hover:bg-background/80 truncate text-left"
            >
              / {getActiveFolderStack().slice(1).join("/")}
            </button>
          )}
        </div>

        {/* Breadcrumb */}
        <nav className="text-sm text-muted-foreground flex-wrap flex gap-1">
          {getActiveFolderStack().map((f, idx) => (
            <button
              key={idx}
              onClick={() => setActiveFolderStack(getActiveFolderStack().slice(0, idx + 1))}
              className="hover:underline hover:text-foreground px-1 py-0.5 rounded hover:bg-primary/10 transition-colors"
              title={`Navigate to ${f === "root" ? "Home" : f}`}
            >
              {f === "root" ? "Home" : f}
              {idx < getActiveFolderStack().length - 1 && <span className="ml-1">/</span>}
            </button>
          ))}
        </nav>
      </div>

      {/* Main content */}
      <div className="flex-1 flex flex-col">
        {/* Toolbar */}
          <div className="flex items-center gap-2 p-2 bg-card border-b border-border">
          {folderStack.length > 1 && (
            <Button size="sm" variant="ghost" onClick={navigateUp}>
              ← Up
            </Button>
          )}
          <div className="flex items-center gap-2">
            <nav className="text-sm text-muted-foreground">
              {folderStack.map((f, idx) => (
                <button
                  key={idx}
                  onClick={() => setFolderStack((s) => s.slice(0, idx + 1))}
                  className="hover:underline mr-1"
                >
                  {f === "root" ? "Home" : f}
                </button>
              ))}
            </nav>
          </div>
          <div className="ml-4 flex items-center gap-2">
            <div className="relative">
              <input
                type="text"
                placeholder="Search files..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="px-2 py-1 text-sm bg-background border border-border rounded focus:border-primary outline-none"
              />
              <SearchIcon className="absolute right-2 top-2 w-4 h-4 text-muted-foreground" />
            </div>
            <select value={sortBy} onChange={(e) => setSortBy(e.target.value as any)} className="text-sm px-2 py-1 bg-background border border-border rounded">
              <option value="name">Sort: Name</option>
              <option value="type">Sort: Type</option>
            </select>
          </div>
          <div className="flex-1" />
          <input ref={fileInputRef} type="file" multiple onChange={(e) => handleUploadFiles(e.target.files)} className="hidden" />
          <Button size="sm" variant="ghost" onClick={() => fileInputRef.current?.click()}>
            <Upload className="w-4 h-4 mr-1" /> Upload
          </Button>
          <Button size="sm" variant="ghost" onClick={() => { setIsCreating(true); setCreateType("folder"); }}>
            <Folder className="w-4 h-4 mr-1" /> New Folder
          </Button>
          <Button size="sm" variant="ghost" onClick={() => { setIsCreating(true); setCreateType("file"); }}>
            <Plus className="w-4 h-4 mr-1" /> New File
          </Button>
        </div>

        {/* Create dialog */}
        {isCreating && (
          <div className="p-2 bg-card/50 border-b border-border flex items-center gap-2">
            <input
              type="text"
              value={newName}
              onChange={(e) => setNewName(e.target.value)}
              placeholder={`New ${createType} name...`}
              className="flex-1 px-2 py-1 text-sm bg-background border border-border rounded focus:border-primary outline-none"
              autoFocus
              onKeyDown={(e) => e.key === "Enter" && createItem()}
            />
            <Button size="sm" onClick={createItem}>Create</Button>
            <Button size="sm" variant="ghost" onClick={() => setIsCreating(false)}>Cancel</Button>
          </div>
        )}

        <div className="flex-1 flex overflow-hidden">
          {/* Files grid */}
          <div className="flex-1 p-4 overflow-auto">
            <div className="grid grid-cols-4 gap-4">
              {(() => {
                let list = files.slice();
                if (searchTerm.trim()) list = list.filter((f) => f.name.toLowerCase().includes(searchTerm.toLowerCase()));
                if (sortBy === "name") list.sort((a, b) => a.name.localeCompare(b.name));
                else list.sort((a, b) => a.file_type.localeCompare(b.file_type));
                return list.map((file) => (
                  <div
                    key={file.id}
                    draggable={true}
                    onDragStart={() => setDraggedItem(file.id)}
                    onDragEnd={() => setDraggedItem(null)}
                    onDragOver={(e) => {
                      e.preventDefault();
                      if (file.file_type === "folder") setDragOverFolder(file.id);
                    }}
                    onDragLeave={() => setDragOverFolder(null)}
                    onDrop={(e) => {
                      e.preventDefault();
                      if (draggedItem && file.file_type === "folder") {
                        moveItemToFolder(draggedItem, file.name);
                        setDragOverFolder(null);
                      }
                    }}
                    onDoubleClick={() => openItem(file)}
                    onClick={() => setSelectedFile(file)}
                    onContextMenu={(e) => { e.preventDefault(); setContextMenu({ x: e.clientX, y: e.clientY, id: file.id }); }}
                    className={`flex flex-col items-center gap-2 p-3 rounded-lg cursor-pointer transition-all ${
                      selectedFile?.id === file.id ? "bg-primary/20 shadow-md" : "hover:bg-card"
                    } ${dragOverFolder === file.id ? "bg-primary/30 border-2 border-primary" : ""} ${draggedItem === file.id ? "opacity-50" : ""}`}
                  >
                    <div className="flex items-start w-full justify-between">
                      <input type="checkbox" checked={multiSelect.includes(file.id)} onChange={() => toggleSelect(file.id)} onClick={(e) => e.stopPropagation()} className="accent-primary" />
                      {draggedItem === file.id && <GripVertical className="w-4 h-4 text-muted-foreground" />}
                    </div>
                    <div style={{ width: 'calc(var(--desktop-icon-size) * 0.9)', height: 'calc(var(--desktop-icon-size) * 0.9)' }} className="flex items-center justify-center">
                      {getFileIcon(file.file_type, file.name)}
                    </div>
                    <span className="text-sm text-center truncate w-full">{file.name}</span>
                  </div>
                ));
              })()}
              {files.length === 0 && (
                <p className="col-span-4 text-center text-muted-foreground py-8">
                  This folder is empty
                </p>
              )}
            </div>
          </div>

          {/* File preview */}
          {selectedFile && (
            <div className="w-96 bg-card/50 border-l border-border p-4 overflow-auto">
              <div className="flex items-center justify-between mb-4">
                <div className="flex items-center gap-2">
                  {getFileIcon(selectedFile.file_type, selectedFile.name)}
                  <h3 className="font-semibold text-sm truncate">{selectedFile.name}</h3>
                </div>
                <div className="flex items-center gap-2">
                  {selectedFile.file_type !== "folder" && (
                    <>
                      <Button size="sm" variant="ghost" onClick={() => renameItem(selectedFile.id)} title="Rename">
                        <Edit2 className="w-4 h-4" />
                      </Button>
                      <Button size="sm" variant="ghost" onClick={() => downloadItem(selectedFile)} title="Download">
                        <Download className="w-4 h-4" />
                      </Button>
                    </>
                  )}
                  <Button size="sm" variant="ghost" onClick={() => deleteItem(selectedFile.id)} title="Delete">
                    <Trash2 className="w-4 h-4 text-destructive" />
                  </Button>
                </div>
              </div>

              {/* File info section */}
              <div className="bg-background/50 p-3 rounded mb-3 border border-border/50">
                <h4 className="text-xs font-semibold text-muted-foreground mb-2 uppercase">Information</h4>
                <div className="text-xs text-muted-foreground space-y-1">
                  <p><strong>Type:</strong> {selectedFile.file_type === "folder" ? "Folder" : selectedFile.file_type}</p>
                  <p><strong>Location:</strong> /{selectedFile.parent_folder}</p>
                  <p><strong>Size:</strong> {selectedFile.content ? `${selectedFile.content.length} bytes` : "—"}</p>
                </div>
              </div>

              {/* File preview */}
              {selectedFile.content && selectedFile.file_type === "image" && (
                <div className="mb-3">
                  <h4 className="text-xs font-semibold text-muted-foreground mb-2 uppercase">Preview</h4>
                  <img src={selectedFile.content} alt={selectedFile.name} className="w-full rounded border border-border/50 max-h-48 object-cover" />
                </div>
              )}

              {selectedFile.content && selectedFile.file_type !== "image" && selectedFile.file_type !== "folder" && (
                <div className="mb-3">
                  <h4 className="text-xs font-semibold text-muted-foreground mb-2 uppercase">Preview</h4>
                  <div className="bg-black/50 rounded border border-border/50 text-xs font-mono text-green-400 max-h-48 overflow-auto p-2">
                    <pre className="whitespace-pre-wrap break-words">{selectedFile.content.substring(0, 500)}{selectedFile.content.length > 500 ? "..." : ""}</pre>
                  </div>
                </div>
              )}

              {/* Actions */}
              <div className="space-y-2">
                {selectedFile.file_type !== "folder" && (
                  <>
                    <Button size="sm" className="w-full" onClick={() => moveToRoot(selectedFile.id)}>
                      <Move className="w-4 h-4 mr-2" /> Move to Home
                    </Button>
                    <Button size="sm" className="w-full" variant="secondary" onClick={() => { navigator.clipboard?.writeText(selectedFile.name); toast({ title: "Copied" }); }}>
                      <Copy className="w-4 h-4 mr-2" /> Copy Name
                    </Button>
                  </>
                )}
              </div>
            </div>
          )}
          {contextMenu && (
            <div
              style={{ left: contextMenu.x, top: contextMenu.y }}
              className="fixed z-50 bg-card border border-border rounded shadow-lg p-1 min-w-max"
              onMouseLeave={() => setContextMenu(null)}
            >
              <button
                className="flex items-center gap-2 w-full px-3 py-2 text-sm hover:bg-primary/10 rounded transition-colors"
                onClick={() => { renameItem(contextMenu.id); setContextMenu(null); }}
              >
                <Edit2 className="w-4 h-4" /> Rename
              </button>
              <button
                className="flex items-center gap-2 w-full px-3 py-2 text-sm hover:bg-primary/10 rounded transition-colors"
                onClick={() => { downloadItem(files.find(f => f.id === contextMenu.id)!); setContextMenu(null); }}
              >
                <Download className="w-4 h-4" /> Download
              </button>
              <button
                className="flex items-center gap-2 w-full px-3 py-2 text-sm hover:bg-primary/10 rounded transition-colors"
                onClick={() => { moveToRoot(contextMenu.id); setContextMenu(null); }}
              >
                <Move className="w-4 h-4" /> Move to Home
              </button>
              <hr className="my-1 border-border/50" />
              <button
                className="flex items-center gap-2 w-full px-3 py-2 text-sm hover:bg-destructive/10 text-destructive rounded transition-colors"
                onClick={() => { deleteItem(contextMenu.id); setContextMenu(null); }}
              >
                <Trash2 className="w-4 h-4" /> Delete
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
